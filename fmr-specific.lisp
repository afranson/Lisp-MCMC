;;;; FMR specific helper functions for lorentzians

(in-package :mcmc-fitting)

(defun data->guess-lorder-mixed-bg-params (data)
  (let ((x-data (elt data 0))
	(y-data (elt data 1)))
   (destructuring-bind (x-diff y-diff) (diff-list x-data y-data)
     (let* ((center-pos (position (reduce #'max y-diff) y-diff))
	    (center-pos (if center-pos center-pos (floor (length x-data) 2)))
	    (center-x (elt x-diff center-pos))
	    (center-y (elt y-data center-pos))
	    (right-peak-pos (position 0 y-diff :test #'(lambda (x y) (> x y)) :start center-pos))
	    (right-peak-pos (if right-peak-pos right-peak-pos (+ 1 (floor (length x-data) 2))))
	    (right-peak-x (elt x-diff right-peak-pos))
	    (right-peak-y (elt y-data right-peak-pos))
	    (bg1 (/ (reduce #'+ y-diff) (length y-diff)))
	    (bg0 (- center-y (* bg1 center-x)))
	    (x-spacing (- (fifth x-data) (fourth x-data))))
       (list :x0 center-x :linewidth (max (* 10 x-spacing) (* 2 (sqrt 3) (- right-peak-x center-x)))
	     :scale (- right-peak-y center-y) :mix 0.1d0
	     :bg0 bg0 :bg1 bg1)))))

(defun log-liklihood-lorder (fn params data error)
  (declare (optimize speed)
	   (cons data)
	   (function fn))
  (let* ((x0 (getf params :x0))
	 (lw (/ (the double-float (getf params :linewidth)) 2d0))
	 (low-x (- x0 lw))
	 (high-x (+ x0 lw))
	 (data (remove-if-not #'(lambda (x) (declare (double-float x)) (< low-x x high-x)) data))
	 (x (elt data 0))
	 (y (elt data 1)))
    (declare (simple-vector x y)
	     (double-float x0 low-x high-x lw))
    (reduce #'+ (map 'vector #'(lambda (x y) (log-normal (apply fn x params) error y)) x y))))

(defun log-prior-lorder (params data)
  (declare (optimize speed)
	   (cons data)
	   (ignore params))
  (let ((x (elt data 0))
	(y (elt data 1)))
    (declare (simple-vector x y))
    (let ((max-y (reduce #'max y))
	  (min-y (reduce #'min y))
	  (min-x (elt x 0))
	  (max-x (elt x (- (length x) 1))))
      (declare (double-float max-y min-y max-x min-x))
      (lambda (params data)
	(declare (ignore data))
	(prior-bounds-let ((:x0 min-x max-x)
			   (:scale 1e-8 (* 2 (abs (- max-y min-y))))
			   (:linewidth 5 200))
	  bounds-total)))))

(defun log-prior-lorder-mixed (params data)
  (declare (optimize speed)
	   (cons data)
	   (ignore params))
  (let ((x (elt data 0))
	(y (elt data 1)))
    (declare (simple-array x y))
    (let ((max-y (reduce #'max y))
	  (min-y (reduce #'min y))
	  (min-x (elt x 0))
	  (max-x (elt x (- (length x) 1))))
      (declare (double-float max-y min-y max-x min-x))
      (lambda (params data)
	(declare (ignore data))
	(prior-bounds-let ((:x0 min-x max-x)
			   (:scale 1e-8 (* 2 (abs (- max-y min-y))))
			   (:linewidth 5 200)
			   (:mix (- pi) pi))
	  bounds-total)))))

(defun lorder-conditioning (data)
  (let* ((x-data (subseq (elt data 1) 10))
	 (y-data (subseq (elt data 4) 10))
	 (f-data (subseq (elt data 6) 10))
	 (p-data (subseq (elt data 7) 10))
	 (total (map 'list #'list x-data y-data f-data p-data))
	 (clean-total (remove-if #'(lambda (x) (= (second x) 0)) total))
	 (x-data (mapcar #'first clean-total))
	 (y-data (mapcar #'second clean-total))
	 (f-data (mapcar #'third clean-total))
	 (p-data (mapcar #'fourth clean-total)))
    (list x-data y-data f-data p-data)))

(defun 10ghz-lorder-cond (data)
  (let* ((data (funcall #'lorder-conditioning data))
	 (x-data (elt data 0))
	 (y-data (elt data 1))
	 (f-data (elt data 2))
	 (p-data (elt data 3))
	 (x-first (position 600 x-data :test #'<))
	 (x-last (position 1000 x-data :test #'<))
	 (x-data (subseq x-data x-first x-last))
	 (y-data (subseq y-data x-first x-last)))
    (list x-data y-data f-data p-data)))

(defun lorder-data-std-dev (data)
  (let* ((y-data (elt data 4))
	 (y-length/10 (floor (length y-data) 10))
	 (y-start-std-dev (standard-deviation (subseq y-data 0 y-length/10)))
	 (y-end-std-dev (standard-deviation (subseq y-data (- (length y-data) y-length/10)))))
    (min y-start-std-dev y-end-std-dev)))


(defun lorder-walker (data error &optional params)
  (unless params (setq params (data->guess-lorder-mixed-bg-params (map-matrix #'(lambda (x) (float x 1.0d0)) data))))
  (create-walker #'lorder params data error #'log-liklihood-normal #'log-prior-lorder))

(defun lorder-bg-walker (data error &optional params)
  (unless params (setq params (data->guess-lorder-mixed-bg-params (map-matrix #'(lambda (x) (float x 1.0d0)) data))))
  (create-walker #'lorder+bg params data error #'log-liklihood-normal #'log-prior-lorder-mixed))

(defun lorder-mixed-bg-walker (data error &optional params)
  (unless params (setq params (data->guess-lorder-mixed-bg-params (map-matrix #'(lambda (x) (float x 1.0d0)) data))))
  (create-walker #'lorder-mixed-bg params data error #'log-liklihood-normal #'log-prior-lorder-mixed))


 

(defun file->lorder-walker-easy (filename &key (walker-function #'lorder-mixed-bg-walker) (conditioning-function #'lorder-conditioning) params)
  (let* ((data (file->data-list filename))
	 (the-walker (funcall walker-function (funcall conditioning-function data) (lorder-data-std-dev data) params)))
    (walker-adaptive-steps the-walker)
    the-walker))

(defun file->lorder-walker-custom (filename walker-function conditioning-function &optional (n 100000) (temp 1000) (auto t) params)
  (let* ((data (file->data-list filename))
	 (the-walker (funcall walker-function (funcall conditioning-function data) (lorder-data-std-dev data) params)))
    (walker-adaptive-steps-full the-walker n temp auto)
    the-walker))

(defun file->lorder-walker (filename walker-function conditioning-function &optional params)
  (let* ((data (file->data-list filename))
	 (the-walker (funcall walker-function (funcall conditioning-function data) (lorder-data-std-dev data) params)))
    the-walker))

(defun directory->lorder-fits (directory walker-function conditioning-function &optional (n 30000) (temperature 10) init-params)
  (let ((data-files (remove-bad-files (uiop:directory-files directory))))
    (mapcar #'(lambda (x) (file->lorder-walker x walker-function conditioning-function init-params)) data-files)))



;;; 2nd level fits helpers (crunch frequency and angular sweep into one massive set)
(defun crunch-walkers-into-data (angular-walkers freq-walkers)
  (let ((phis (linspace 0 (* 2 pi) :steps (length angular-walkers)))
	(happ-phis (walker-set-get-median-params angular-walkers :x0 1000))
	(phi-w (list (elt (walker-get-data-column (elt angular-walkers 0) 2) 0)))
	(freqs (mapcar #'(lambda (x) (elt (walker-get-data-column x 2) 0)) freq-walkers))
	(happ-freqs (walker-set-get-median-params freq-walkers :x0 1000)))
    (list phis happ-phis phi-w freqs happ-freqs)))

(defun crunch-walkers-into-error (angular-walkers freq-walkers)
  (let ((happ-phis-error (walker-set-get-stddev-params angular-walkers :x0 1000))
	(happ-freqs-error (walker-set-get-stddev-params freq-walkers :x0 1000)))
    (list happ-phis-error happ-freqs-error)))

(defun crunch-freq-walkers-into-data (freq-walkers)
  (let ((freqs (mapcar #'(lambda (x) (elt (walker-get-data-column x 2) 0)) freq-walkers))
	(happ-freqs (walker-set-get-median-params freq-walkers :x0 1000)))
    (list freqs happ-freqs)))

(defun crunch-freq-walkers-into-linewidth-data (freq-walkers)
  (let ((freqs (mapcar #'(lambda (x) (elt (walker-get-data-column x 2) 0)) freq-walkers))
	(dH-freqs (walker-set-get-median-params freq-walkers :linewidth 1000)))
    (list freqs dH-freqs)))

(defun crunch-freq-walkers-into-error (freq-walkers)
  (walker-set-get-stddev-params freq-walkers :x0 1000))

(defun crunch-freq-walkers-into-linewidth-error (freq-walkers)
  (walker-set-get-stddev-params freq-walkers :linewidth 1000))

;; (defun angular+freq-walker (angle-file freq-file)
;;   (let* ((angle-walkers (walker-set-load angle-file #'lorder-mixed-bg #'log-liklihood-normal #'log-prior-lorder-mixed))
;; 	 (freq-walkers (walker-set-load freq-file #'lorder-mixed-bg #'log-liklihood-normal #'log-prior-lorder-mixed)))
;;     (setf woi (create-walker (list #'in-plane-fmr-happ-p #'in-plane-fmr-happ-w)
;; 			     '(:c-w 10d0 :meff 12000 :gamma 0.0028 :hu 20d0 :phi-offset 0.1 :c-phi-offset 0.2 :%-complete 0.9)
;; 			     (crunch-walkers-into-data angle-walkers freq-walkers)
;; 			     (crunch-walkers-into-error angle-walkers freq-walkers)
;; 			     #'log-liklihood-normal-angular+freq
;; 			     #'log-prior-angular+freq))))

;; (angular+freq-walker "d027_walkers.txt" "d027_freq_walkers.txt")
;; (angular+freq-walker "d028_walkers.txt" "d028_freq_walkers.txt")
;; (angular+freq-walker "d029_walkers.txt" "d029_freq_walkers.txt")
;; (angular+freq-walker "d030_walkers.txt" "d030_freq_walkers.txt")
;; (defparameter fgbtf-walker (mapcar #'walker-full-fit-load '("d027_fullfit.txt" "d028_fullfit.txt" "d029_fullfit.txt" "d030_fullfit.txt")))
;; (format t "~{ ~{ ~2,6f ~} ~%~}" (walker-set-get-f fgbtf-walker (list :meff :gamma :hu) 1000))

;; (walker-adaptive-steps woi 100000 1000)


(defun walker-full-fit-load (filename)
  (walker-load filename (list #'in-plane-fmr-happ-p #'in-plane-fmr-happ-w) #'log-liklihood-normal-angular+freq #'log-prior-angular+freq))



(defun walker-fmr-plot-data-and-fit (the-walker &key (take 1000) (x-column 0) (y-column 1) (fn-number 0))
  (walker-plot-data-and-fit the-walker :take take :x-column x-column :y-column y-column :fn-number fn-number)
  (xlabel "Field (Oe)")
  (ylabel "Intensity (a.u.)")
  (let* ((params (walker-get-median-params the-walker take))
	 (x (getf params :x0))
	 (lw (getf params :linewidth))
	 (offset (getf params :bg0))
	 (scale (getf params :scale)))
    (text (float (+ x lw) 0e0) (float (/ (+ offset scale) 2) 0e0) (format nil "Resonance Field: ~,1f Oe\\nFWHM Linewidth: ~,1f Oe" x lw))
    params))
